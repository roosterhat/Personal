// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cache.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Cache_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Cache_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Cache_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Cache_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Cache_2eproto;
namespace cache {
class DFA;
class DFADefaultTypeInternal;
extern DFADefaultTypeInternal _DFA_default_instance_;
class Matcher;
class MatcherDefaultTypeInternal;
extern MatcherDefaultTypeInternal _Matcher_default_instance_;
class Pair;
class PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class Regex;
class RegexDefaultTypeInternal;
extern RegexDefaultTypeInternal _Regex_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class V_1D;
class V_1DDefaultTypeInternal;
extern V_1DDefaultTypeInternal _V_1D_default_instance_;
class V_2D;
class V_2DDefaultTypeInternal;
extern V_2DDefaultTypeInternal _V_2D_default_instance_;
}  // namespace cache
PROTOBUF_NAMESPACE_OPEN
template<> ::cache::DFA* Arena::CreateMaybeMessage<::cache::DFA>(Arena*);
template<> ::cache::Matcher* Arena::CreateMaybeMessage<::cache::Matcher>(Arena*);
template<> ::cache::Pair* Arena::CreateMaybeMessage<::cache::Pair>(Arena*);
template<> ::cache::Regex* Arena::CreateMaybeMessage<::cache::Regex>(Arena*);
template<> ::cache::Token* Arena::CreateMaybeMessage<::cache::Token>(Arena*);
template<> ::cache::V_1D* Arena::CreateMaybeMessage<::cache::V_1D>(Arena*);
template<> ::cache::V_2D* Arena::CreateMaybeMessage<::cache::V_2D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cache {

// ===================================================================

class Matcher PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.Matcher) */ {
 public:
  inline Matcher() : Matcher(nullptr) {}
  virtual ~Matcher();

  Matcher(const Matcher& from);
  Matcher(Matcher&& from) noexcept
    : Matcher() {
    *this = ::std::move(from);
  }

  inline Matcher& operator=(const Matcher& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matcher& operator=(Matcher&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Matcher& default_instance();

  static inline const Matcher* internal_default_instance() {
    return reinterpret_cast<const Matcher*>(
               &_Matcher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Matcher& a, Matcher& b) {
    a.Swap(&b);
  }
  inline void Swap(Matcher* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matcher* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Matcher* New() const final {
    return CreateMaybeMessage<Matcher>(nullptr);
  }

  Matcher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Matcher>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Matcher& from);
  void MergeFrom(const Matcher& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matcher* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.Matcher";
  }
  protected:
  explicit Matcher(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 1,
    kExpFieldNumber = 2,
    kTokenFieldNumber = 3,
  };
  // required string pattern = 1;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const std::string& pattern() const;
  void set_pattern(const std::string& value);
  void set_pattern(std::string&& value);
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  std::string* mutable_pattern();
  std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // required .cache.Regex exp = 2;
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;
  public:
  void clear_exp();
  const ::cache::Regex& exp() const;
  ::cache::Regex* release_exp();
  ::cache::Regex* mutable_exp();
  void set_allocated_exp(::cache::Regex* exp);
  private:
  const ::cache::Regex& _internal_exp() const;
  ::cache::Regex* _internal_mutable_exp();
  public:
  void unsafe_arena_set_allocated_exp(
      ::cache::Regex* exp);
  ::cache::Regex* unsafe_arena_release_exp();

  // required .cache.Token token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::cache::Token& token() const;
  ::cache::Token* release_token();
  ::cache::Token* mutable_token();
  void set_allocated_token(::cache::Token* token);
  private:
  const ::cache::Token& _internal_token() const;
  ::cache::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::cache::Token* token);
  ::cache::Token* unsafe_arena_release_token();

  // @@protoc_insertion_point(class_scope:cache.Matcher)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
  ::cache::Regex* exp_;
  ::cache::Token* token_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class Token PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  virtual ~Token();

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Token& default_instance();

  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const final {
    return CreateMaybeMessage<Token>(nullptr);
  }

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kLexemeFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required string lexeme = 2;
  bool has_lexeme() const;
  private:
  bool _internal_has_lexeme() const;
  public:
  void clear_lexeme();
  const std::string& lexeme() const;
  void set_lexeme(const std::string& value);
  void set_lexeme(std::string&& value);
  void set_lexeme(const char* value);
  void set_lexeme(const char* value, size_t size);
  std::string* mutable_lexeme();
  std::string* release_lexeme();
  void set_allocated_lexeme(std::string* lexeme);
  private:
  const std::string& _internal_lexeme() const;
  void _internal_set_lexeme(const std::string& value);
  std::string* _internal_mutable_lexeme();
  public:

  // required uint32 type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:cache.Token)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lexeme_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class Regex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.Regex) */ {
 public:
  inline Regex() : Regex(nullptr) {}
  virtual ~Regex();

  Regex(const Regex& from);
  Regex(Regex&& from) noexcept
    : Regex() {
    *this = ::std::move(from);
  }

  inline Regex& operator=(const Regex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Regex& operator=(Regex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Regex& default_instance();

  static inline const Regex* internal_default_instance() {
    return reinterpret_cast<const Regex*>(
               &_Regex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Regex& a, Regex& b) {
    a.Swap(&b);
  }
  inline void Swap(Regex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Regex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Regex* New() const final {
    return CreateMaybeMessage<Regex>(nullptr);
  }

  Regex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Regex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Regex& from);
  void MergeFrom(const Regex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Regex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.Regex";
  }
  protected:
  explicit Regex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 2,
    kDfaFieldNumber = 1,
  };
  // required string expression = 2;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;
  public:
  void clear_expression();
  const std::string& expression() const;
  void set_expression(const std::string& value);
  void set_expression(std::string&& value);
  void set_expression(const char* value);
  void set_expression(const char* value, size_t size);
  std::string* mutable_expression();
  std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // required .cache.DFA dfa = 1;
  bool has_dfa() const;
  private:
  bool _internal_has_dfa() const;
  public:
  void clear_dfa();
  const ::cache::DFA& dfa() const;
  ::cache::DFA* release_dfa();
  ::cache::DFA* mutable_dfa();
  void set_allocated_dfa(::cache::DFA* dfa);
  private:
  const ::cache::DFA& _internal_dfa() const;
  ::cache::DFA* _internal_mutable_dfa();
  public:
  void unsafe_arena_set_allocated_dfa(
      ::cache::DFA* dfa);
  ::cache::DFA* unsafe_arena_release_dfa();

  // @@protoc_insertion_point(class_scope:cache.Regex)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
  ::cache::DFA* dfa_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class DFA PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.DFA) */ {
 public:
  inline DFA() : DFA(nullptr) {}
  virtual ~DFA();

  DFA(const DFA& from);
  DFA(DFA&& from) noexcept
    : DFA() {
    *this = ::std::move(from);
  }

  inline DFA& operator=(const DFA& from) {
    CopyFrom(from);
    return *this;
  }
  inline DFA& operator=(DFA&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DFA& default_instance();

  static inline const DFA* internal_default_instance() {
    return reinterpret_cast<const DFA*>(
               &_DFA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DFA& a, DFA& b) {
    a.Swap(&b);
  }
  inline void Swap(DFA* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DFA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DFA* New() const final {
    return CreateMaybeMessage<DFA>(nullptr);
  }

  DFA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DFA>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DFA& from);
  void MergeFrom(const DFA& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DFA* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.DFA";
  }
  protected:
  explicit DFA(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphabetFieldNumber = 3,
    kFinalSFieldNumber = 4,
    kAlphaIndexFieldNumber = 5,
    kTransitionsFieldNumber = 6,
    kStatesFieldNumber = 1,
    kInitialFieldNumber = 2,
  };
  // repeated uint32 alphabet = 3;
  int alphabet_size() const;
  private:
  int _internal_alphabet_size() const;
  public:
  void clear_alphabet();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_alphabet(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_alphabet() const;
  void _internal_add_alphabet(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_alphabet();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 alphabet(int index) const;
  void set_alphabet(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_alphabet(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      alphabet() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_alphabet();

  // repeated uint32 final_s = 4;
  int final_s_size() const;
  private:
  int _internal_final_s_size() const;
  public:
  void clear_final_s();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_final_s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_final_s() const;
  void _internal_add_final_s(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_final_s();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 final_s(int index) const;
  void set_final_s(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_final_s(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      final_s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_final_s();

  // repeated .cache.Pair alpha_index = 5;
  int alpha_index_size() const;
  private:
  int _internal_alpha_index_size() const;
  public:
  void clear_alpha_index();
  ::cache::Pair* mutable_alpha_index(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::Pair >*
      mutable_alpha_index();
  private:
  const ::cache::Pair& _internal_alpha_index(int index) const;
  ::cache::Pair* _internal_add_alpha_index();
  public:
  const ::cache::Pair& alpha_index(int index) const;
  ::cache::Pair* add_alpha_index();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::Pair >&
      alpha_index() const;

  // repeated .cache.V_2D transitions = 6;
  int transitions_size() const;
  private:
  int _internal_transitions_size() const;
  public:
  void clear_transitions();
  ::cache::V_2D* mutable_transitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_2D >*
      mutable_transitions();
  private:
  const ::cache::V_2D& _internal_transitions(int index) const;
  ::cache::V_2D* _internal_add_transitions();
  public:
  const ::cache::V_2D& transitions(int index) const;
  ::cache::V_2D* add_transitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_2D >&
      transitions() const;

  // required uint32 states = 1;
  bool has_states() const;
  private:
  bool _internal_has_states() const;
  public:
  void clear_states();
  ::PROTOBUF_NAMESPACE_ID::uint32 states() const;
  void set_states(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_states() const;
  void _internal_set_states(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 initial = 2;
  bool has_initial() const;
  private:
  bool _internal_has_initial() const;
  public:
  void clear_initial();
  ::PROTOBUF_NAMESPACE_ID::uint32 initial() const;
  void set_initial(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_initial() const;
  void _internal_set_initial(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:cache.DFA)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > alphabet_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > final_s_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::Pair > alpha_index_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_2D > transitions_;
  ::PROTOBUF_NAMESPACE_ID::uint32 states_;
  ::PROTOBUF_NAMESPACE_ID::uint32 initial_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class Pair PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.Pair) */ {
 public:
  inline Pair() : Pair(nullptr) {}
  virtual ~Pair();

  Pair(const Pair& from);
  Pair(Pair&& from) noexcept
    : Pair() {
    *this = ::std::move(from);
  }

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pair& operator=(Pair&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pair& default_instance();

  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Pair& a, Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(Pair* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pair* New() const final {
    return CreateMaybeMessage<Pair>(nullptr);
  }

  Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.Pair";
  }
  protected:
  explicit Pair(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required uint32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  ::PROTOBUF_NAMESPACE_ID::uint32 key() const;
  void set_key(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key() const;
  void _internal_set_key(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:cache.Pair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class V_2D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.V_2D) */ {
 public:
  inline V_2D() : V_2D(nullptr) {}
  virtual ~V_2D();

  V_2D(const V_2D& from);
  V_2D(V_2D&& from) noexcept
    : V_2D() {
    *this = ::std::move(from);
  }

  inline V_2D& operator=(const V_2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline V_2D& operator=(V_2D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const V_2D& default_instance();

  static inline const V_2D* internal_default_instance() {
    return reinterpret_cast<const V_2D*>(
               &_V_2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(V_2D& a, V_2D& b) {
    a.Swap(&b);
  }
  inline void Swap(V_2D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V_2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline V_2D* New() const final {
    return CreateMaybeMessage<V_2D>(nullptr);
  }

  V_2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<V_2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const V_2D& from);
  void MergeFrom(const V_2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(V_2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.V_2D";
  }
  protected:
  explicit V_2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayFieldNumber = 1,
  };
  // repeated .cache.V_1D array = 1;
  int array_size() const;
  private:
  int _internal_array_size() const;
  public:
  void clear_array();
  ::cache::V_1D* mutable_array(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_1D >*
      mutable_array();
  private:
  const ::cache::V_1D& _internal_array(int index) const;
  ::cache::V_1D* _internal_add_array();
  public:
  const ::cache::V_1D& array(int index) const;
  ::cache::V_1D* add_array();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_1D >&
      array() const;

  // @@protoc_insertion_point(class_scope:cache.V_2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_1D > array_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cache_2eproto;
};
// -------------------------------------------------------------------

class V_1D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cache.V_1D) */ {
 public:
  inline V_1D() : V_1D(nullptr) {}
  virtual ~V_1D();

  V_1D(const V_1D& from);
  V_1D(V_1D&& from) noexcept
    : V_1D() {
    *this = ::std::move(from);
  }

  inline V_1D& operator=(const V_1D& from) {
    CopyFrom(from);
    return *this;
  }
  inline V_1D& operator=(V_1D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const V_1D& default_instance();

  static inline const V_1D* internal_default_instance() {
    return reinterpret_cast<const V_1D*>(
               &_V_1D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(V_1D& a, V_1D& b) {
    a.Swap(&b);
  }
  inline void Swap(V_1D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V_1D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline V_1D* New() const final {
    return CreateMaybeMessage<V_1D>(nullptr);
  }

  V_1D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<V_1D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const V_1D& from);
  void MergeFrom(const V_1D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(V_1D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cache.V_1D";
  }
  protected:
  explicit V_1D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Cache_2eproto);
    return ::descriptor_table_Cache_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated int32 item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  void clear_item();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_item(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_item() const;
  void _internal_add_item(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_item();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 item(int index) const;
  void set_item(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_item(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      item() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:cache.V_1D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Cache_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Matcher

// required string pattern = 1;
inline bool Matcher::_internal_has_pattern() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Matcher::has_pattern() const {
  return _internal_has_pattern();
}
inline void Matcher::clear_pattern() {
  pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Matcher::pattern() const {
  // @@protoc_insertion_point(field_get:cache.Matcher.pattern)
  return _internal_pattern();
}
inline void Matcher::set_pattern(const std::string& value) {
  _internal_set_pattern(value);
  // @@protoc_insertion_point(field_set:cache.Matcher.pattern)
}
inline std::string* Matcher::mutable_pattern() {
  // @@protoc_insertion_point(field_mutable:cache.Matcher.pattern)
  return _internal_mutable_pattern();
}
inline const std::string& Matcher::_internal_pattern() const {
  return pattern_.Get();
}
inline void Matcher::_internal_set_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Matcher::set_pattern(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cache.Matcher.pattern)
}
inline void Matcher::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:cache.Matcher.pattern)
}
inline void Matcher::set_pattern(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cache.Matcher.pattern)
}
inline std::string* Matcher::_internal_mutable_pattern() {
  _has_bits_[0] |= 0x00000001u;
  return pattern_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Matcher::release_pattern() {
  // @@protoc_insertion_point(field_release:cache.Matcher.pattern)
  if (!_internal_has_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pattern_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Matcher::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pattern_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pattern,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cache.Matcher.pattern)
}

// required .cache.Regex exp = 2;
inline bool Matcher::_internal_has_exp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || exp_ != nullptr);
  return value;
}
inline bool Matcher::has_exp() const {
  return _internal_has_exp();
}
inline void Matcher::clear_exp() {
  if (exp_ != nullptr) exp_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::cache::Regex& Matcher::_internal_exp() const {
  const ::cache::Regex* p = exp_;
  return p != nullptr ? *p : reinterpret_cast<const ::cache::Regex&>(
      ::cache::_Regex_default_instance_);
}
inline const ::cache::Regex& Matcher::exp() const {
  // @@protoc_insertion_point(field_get:cache.Matcher.exp)
  return _internal_exp();
}
inline void Matcher::unsafe_arena_set_allocated_exp(
    ::cache::Regex* exp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exp_);
  }
  exp_ = exp;
  if (exp) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cache.Matcher.exp)
}
inline ::cache::Regex* Matcher::release_exp() {
  _has_bits_[0] &= ~0x00000002u;
  ::cache::Regex* temp = exp_;
  exp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cache::Regex* Matcher::unsafe_arena_release_exp() {
  // @@protoc_insertion_point(field_release:cache.Matcher.exp)
  _has_bits_[0] &= ~0x00000002u;
  ::cache::Regex* temp = exp_;
  exp_ = nullptr;
  return temp;
}
inline ::cache::Regex* Matcher::_internal_mutable_exp() {
  _has_bits_[0] |= 0x00000002u;
  if (exp_ == nullptr) {
    auto* p = CreateMaybeMessage<::cache::Regex>(GetArena());
    exp_ = p;
  }
  return exp_;
}
inline ::cache::Regex* Matcher::mutable_exp() {
  // @@protoc_insertion_point(field_mutable:cache.Matcher.exp)
  return _internal_mutable_exp();
}
inline void Matcher::set_allocated_exp(::cache::Regex* exp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete exp_;
  }
  if (exp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(exp);
    if (message_arena != submessage_arena) {
      exp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  exp_ = exp;
  // @@protoc_insertion_point(field_set_allocated:cache.Matcher.exp)
}

// required .cache.Token token = 3;
inline bool Matcher::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || token_ != nullptr);
  return value;
}
inline bool Matcher::has_token() const {
  return _internal_has_token();
}
inline void Matcher::clear_token() {
  if (token_ != nullptr) token_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::cache::Token& Matcher::_internal_token() const {
  const ::cache::Token* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::cache::Token&>(
      ::cache::_Token_default_instance_);
}
inline const ::cache::Token& Matcher::token() const {
  // @@protoc_insertion_point(field_get:cache.Matcher.token)
  return _internal_token();
}
inline void Matcher::unsafe_arena_set_allocated_token(
    ::cache::Token* token) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cache.Matcher.token)
}
inline ::cache::Token* Matcher::release_token() {
  _has_bits_[0] &= ~0x00000004u;
  ::cache::Token* temp = token_;
  token_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cache::Token* Matcher::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:cache.Matcher.token)
  _has_bits_[0] &= ~0x00000004u;
  ::cache::Token* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::cache::Token* Matcher::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000004u;
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::cache::Token>(GetArena());
    token_ = p;
  }
  return token_;
}
inline ::cache::Token* Matcher::mutable_token() {
  // @@protoc_insertion_point(field_mutable:cache.Matcher.token)
  return _internal_mutable_token();
}
inline void Matcher::set_allocated_token(::cache::Token* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:cache.Matcher.token)
}

// -------------------------------------------------------------------

// Token

// required string token = 1;
inline bool Token::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Token::has_token() const {
  return _internal_has_token();
}
inline void Token::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Token::token() const {
  // @@protoc_insertion_point(field_get:cache.Token.token)
  return _internal_token();
}
inline void Token::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:cache.Token.token)
}
inline std::string* Token::mutable_token() {
  // @@protoc_insertion_point(field_mutable:cache.Token.token)
  return _internal_mutable_token();
}
inline const std::string& Token::_internal_token() const {
  return token_.Get();
}
inline void Token::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Token::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cache.Token.token)
}
inline void Token::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:cache.Token.token)
}
inline void Token::set_token(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cache.Token.token)
}
inline std::string* Token::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Token::release_token() {
  // @@protoc_insertion_point(field_release:cache.Token.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Token::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cache.Token.token)
}

// required string lexeme = 2;
inline bool Token::_internal_has_lexeme() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Token::has_lexeme() const {
  return _internal_has_lexeme();
}
inline void Token::clear_lexeme() {
  lexeme_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Token::lexeme() const {
  // @@protoc_insertion_point(field_get:cache.Token.lexeme)
  return _internal_lexeme();
}
inline void Token::set_lexeme(const std::string& value) {
  _internal_set_lexeme(value);
  // @@protoc_insertion_point(field_set:cache.Token.lexeme)
}
inline std::string* Token::mutable_lexeme() {
  // @@protoc_insertion_point(field_mutable:cache.Token.lexeme)
  return _internal_mutable_lexeme();
}
inline const std::string& Token::_internal_lexeme() const {
  return lexeme_.Get();
}
inline void Token::_internal_set_lexeme(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  lexeme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Token::set_lexeme(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  lexeme_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cache.Token.lexeme)
}
inline void Token::set_lexeme(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  lexeme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:cache.Token.lexeme)
}
inline void Token::set_lexeme(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  lexeme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cache.Token.lexeme)
}
inline std::string* Token::_internal_mutable_lexeme() {
  _has_bits_[0] |= 0x00000002u;
  return lexeme_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Token::release_lexeme() {
  // @@protoc_insertion_point(field_release:cache.Token.lexeme)
  if (!_internal_has_lexeme()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return lexeme_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Token::set_allocated_lexeme(std::string* lexeme) {
  if (lexeme != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lexeme_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lexeme,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cache.Token.lexeme)
}

// required uint32 type = 3;
inline bool Token::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Token::has_type() const {
  return _internal_has_type();
}
inline void Token::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::type() const {
  // @@protoc_insertion_point(field_get:cache.Token.type)
  return _internal_type();
}
inline void Token::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Token::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:cache.Token.type)
}

// -------------------------------------------------------------------

// Regex

// required .cache.DFA dfa = 1;
inline bool Regex::_internal_has_dfa() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || dfa_ != nullptr);
  return value;
}
inline bool Regex::has_dfa() const {
  return _internal_has_dfa();
}
inline void Regex::clear_dfa() {
  if (dfa_ != nullptr) dfa_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::cache::DFA& Regex::_internal_dfa() const {
  const ::cache::DFA* p = dfa_;
  return p != nullptr ? *p : reinterpret_cast<const ::cache::DFA&>(
      ::cache::_DFA_default_instance_);
}
inline const ::cache::DFA& Regex::dfa() const {
  // @@protoc_insertion_point(field_get:cache.Regex.dfa)
  return _internal_dfa();
}
inline void Regex::unsafe_arena_set_allocated_dfa(
    ::cache::DFA* dfa) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dfa_);
  }
  dfa_ = dfa;
  if (dfa) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cache.Regex.dfa)
}
inline ::cache::DFA* Regex::release_dfa() {
  _has_bits_[0] &= ~0x00000002u;
  ::cache::DFA* temp = dfa_;
  dfa_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::cache::DFA* Regex::unsafe_arena_release_dfa() {
  // @@protoc_insertion_point(field_release:cache.Regex.dfa)
  _has_bits_[0] &= ~0x00000002u;
  ::cache::DFA* temp = dfa_;
  dfa_ = nullptr;
  return temp;
}
inline ::cache::DFA* Regex::_internal_mutable_dfa() {
  _has_bits_[0] |= 0x00000002u;
  if (dfa_ == nullptr) {
    auto* p = CreateMaybeMessage<::cache::DFA>(GetArena());
    dfa_ = p;
  }
  return dfa_;
}
inline ::cache::DFA* Regex::mutable_dfa() {
  // @@protoc_insertion_point(field_mutable:cache.Regex.dfa)
  return _internal_mutable_dfa();
}
inline void Regex::set_allocated_dfa(::cache::DFA* dfa) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete dfa_;
  }
  if (dfa) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(dfa);
    if (message_arena != submessage_arena) {
      dfa = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dfa, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dfa_ = dfa;
  // @@protoc_insertion_point(field_set_allocated:cache.Regex.dfa)
}

// required string expression = 2;
inline bool Regex::_internal_has_expression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Regex::has_expression() const {
  return _internal_has_expression();
}
inline void Regex::clear_expression() {
  expression_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Regex::expression() const {
  // @@protoc_insertion_point(field_get:cache.Regex.expression)
  return _internal_expression();
}
inline void Regex::set_expression(const std::string& value) {
  _internal_set_expression(value);
  // @@protoc_insertion_point(field_set:cache.Regex.expression)
}
inline std::string* Regex::mutable_expression() {
  // @@protoc_insertion_point(field_mutable:cache.Regex.expression)
  return _internal_mutable_expression();
}
inline const std::string& Regex::_internal_expression() const {
  return expression_.Get();
}
inline void Regex::_internal_set_expression(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Regex::set_expression(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  expression_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:cache.Regex.expression)
}
inline void Regex::set_expression(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:cache.Regex.expression)
}
inline void Regex::set_expression(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  expression_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:cache.Regex.expression)
}
inline std::string* Regex::_internal_mutable_expression() {
  _has_bits_[0] |= 0x00000001u;
  return expression_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Regex::release_expression() {
  // @@protoc_insertion_point(field_release:cache.Regex.expression)
  if (!_internal_has_expression()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return expression_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Regex::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expression_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expression,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:cache.Regex.expression)
}

// -------------------------------------------------------------------

// DFA

// required uint32 states = 1;
inline bool DFA::_internal_has_states() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DFA::has_states() const {
  return _internal_has_states();
}
inline void DFA::clear_states() {
  states_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::_internal_states() const {
  return states_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::states() const {
  // @@protoc_insertion_point(field_get:cache.DFA.states)
  return _internal_states();
}
inline void DFA::_internal_set_states(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  states_ = value;
}
inline void DFA::set_states(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_states(value);
  // @@protoc_insertion_point(field_set:cache.DFA.states)
}

// required uint32 initial = 2;
inline bool DFA::_internal_has_initial() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DFA::has_initial() const {
  return _internal_has_initial();
}
inline void DFA::clear_initial() {
  initial_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::_internal_initial() const {
  return initial_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::initial() const {
  // @@protoc_insertion_point(field_get:cache.DFA.initial)
  return _internal_initial();
}
inline void DFA::_internal_set_initial(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  initial_ = value;
}
inline void DFA::set_initial(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:cache.DFA.initial)
}

// repeated .cache.Pair alpha_index = 5;
inline int DFA::_internal_alpha_index_size() const {
  return alpha_index_.size();
}
inline int DFA::alpha_index_size() const {
  return _internal_alpha_index_size();
}
inline void DFA::clear_alpha_index() {
  alpha_index_.Clear();
}
inline ::cache::Pair* DFA::mutable_alpha_index(int index) {
  // @@protoc_insertion_point(field_mutable:cache.DFA.alpha_index)
  return alpha_index_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::Pair >*
DFA::mutable_alpha_index() {
  // @@protoc_insertion_point(field_mutable_list:cache.DFA.alpha_index)
  return &alpha_index_;
}
inline const ::cache::Pair& DFA::_internal_alpha_index(int index) const {
  return alpha_index_.Get(index);
}
inline const ::cache::Pair& DFA::alpha_index(int index) const {
  // @@protoc_insertion_point(field_get:cache.DFA.alpha_index)
  return _internal_alpha_index(index);
}
inline ::cache::Pair* DFA::_internal_add_alpha_index() {
  return alpha_index_.Add();
}
inline ::cache::Pair* DFA::add_alpha_index() {
  // @@protoc_insertion_point(field_add:cache.DFA.alpha_index)
  return _internal_add_alpha_index();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::Pair >&
DFA::alpha_index() const {
  // @@protoc_insertion_point(field_list:cache.DFA.alpha_index)
  return alpha_index_;
}

// repeated uint32 alphabet = 3;
inline int DFA::_internal_alphabet_size() const {
  return alphabet_.size();
}
inline int DFA::alphabet_size() const {
  return _internal_alphabet_size();
}
inline void DFA::clear_alphabet() {
  alphabet_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::_internal_alphabet(int index) const {
  return alphabet_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::alphabet(int index) const {
  // @@protoc_insertion_point(field_get:cache.DFA.alphabet)
  return _internal_alphabet(index);
}
inline void DFA::set_alphabet(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  alphabet_.Set(index, value);
  // @@protoc_insertion_point(field_set:cache.DFA.alphabet)
}
inline void DFA::_internal_add_alphabet(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  alphabet_.Add(value);
}
inline void DFA::add_alphabet(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_alphabet(value);
  // @@protoc_insertion_point(field_add:cache.DFA.alphabet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DFA::_internal_alphabet() const {
  return alphabet_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DFA::alphabet() const {
  // @@protoc_insertion_point(field_list:cache.DFA.alphabet)
  return _internal_alphabet();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DFA::_internal_mutable_alphabet() {
  return &alphabet_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DFA::mutable_alphabet() {
  // @@protoc_insertion_point(field_mutable_list:cache.DFA.alphabet)
  return _internal_mutable_alphabet();
}

// repeated uint32 final_s = 4;
inline int DFA::_internal_final_s_size() const {
  return final_s_.size();
}
inline int DFA::final_s_size() const {
  return _internal_final_s_size();
}
inline void DFA::clear_final_s() {
  final_s_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::_internal_final_s(int index) const {
  return final_s_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DFA::final_s(int index) const {
  // @@protoc_insertion_point(field_get:cache.DFA.final_s)
  return _internal_final_s(index);
}
inline void DFA::set_final_s(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  final_s_.Set(index, value);
  // @@protoc_insertion_point(field_set:cache.DFA.final_s)
}
inline void DFA::_internal_add_final_s(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  final_s_.Add(value);
}
inline void DFA::add_final_s(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_final_s(value);
  // @@protoc_insertion_point(field_add:cache.DFA.final_s)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DFA::_internal_final_s() const {
  return final_s_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
DFA::final_s() const {
  // @@protoc_insertion_point(field_list:cache.DFA.final_s)
  return _internal_final_s();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DFA::_internal_mutable_final_s() {
  return &final_s_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
DFA::mutable_final_s() {
  // @@protoc_insertion_point(field_mutable_list:cache.DFA.final_s)
  return _internal_mutable_final_s();
}

// repeated .cache.V_2D transitions = 6;
inline int DFA::_internal_transitions_size() const {
  return transitions_.size();
}
inline int DFA::transitions_size() const {
  return _internal_transitions_size();
}
inline void DFA::clear_transitions() {
  transitions_.Clear();
}
inline ::cache::V_2D* DFA::mutable_transitions(int index) {
  // @@protoc_insertion_point(field_mutable:cache.DFA.transitions)
  return transitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_2D >*
DFA::mutable_transitions() {
  // @@protoc_insertion_point(field_mutable_list:cache.DFA.transitions)
  return &transitions_;
}
inline const ::cache::V_2D& DFA::_internal_transitions(int index) const {
  return transitions_.Get(index);
}
inline const ::cache::V_2D& DFA::transitions(int index) const {
  // @@protoc_insertion_point(field_get:cache.DFA.transitions)
  return _internal_transitions(index);
}
inline ::cache::V_2D* DFA::_internal_add_transitions() {
  return transitions_.Add();
}
inline ::cache::V_2D* DFA::add_transitions() {
  // @@protoc_insertion_point(field_add:cache.DFA.transitions)
  return _internal_add_transitions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_2D >&
DFA::transitions() const {
  // @@protoc_insertion_point(field_list:cache.DFA.transitions)
  return transitions_;
}

// -------------------------------------------------------------------

// Pair

// required uint32 key = 1;
inline bool Pair::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Pair::has_key() const {
  return _internal_has_key();
}
inline void Pair::clear_key() {
  key_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pair::_internal_key() const {
  return key_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pair::key() const {
  // @@protoc_insertion_point(field_get:cache.Pair.key)
  return _internal_key();
}
inline void Pair::_internal_set_key(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  key_ = value;
}
inline void Pair::set_key(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:cache.Pair.key)
}

// required uint32 value = 2;
inline bool Pair::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Pair::has_value() const {
  return _internal_has_value();
}
inline void Pair::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pair::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pair::value() const {
  // @@protoc_insertion_point(field_get:cache.Pair.value)
  return _internal_value();
}
inline void Pair::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void Pair::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cache.Pair.value)
}

// -------------------------------------------------------------------

// V_2D

// repeated .cache.V_1D array = 1;
inline int V_2D::_internal_array_size() const {
  return array_.size();
}
inline int V_2D::array_size() const {
  return _internal_array_size();
}
inline void V_2D::clear_array() {
  array_.Clear();
}
inline ::cache::V_1D* V_2D::mutable_array(int index) {
  // @@protoc_insertion_point(field_mutable:cache.V_2D.array)
  return array_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_1D >*
V_2D::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:cache.V_2D.array)
  return &array_;
}
inline const ::cache::V_1D& V_2D::_internal_array(int index) const {
  return array_.Get(index);
}
inline const ::cache::V_1D& V_2D::array(int index) const {
  // @@protoc_insertion_point(field_get:cache.V_2D.array)
  return _internal_array(index);
}
inline ::cache::V_1D* V_2D::_internal_add_array() {
  return array_.Add();
}
inline ::cache::V_1D* V_2D::add_array() {
  // @@protoc_insertion_point(field_add:cache.V_2D.array)
  return _internal_add_array();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::cache::V_1D >&
V_2D::array() const {
  // @@protoc_insertion_point(field_list:cache.V_2D.array)
  return array_;
}

// -------------------------------------------------------------------

// V_1D

// repeated int32 item = 1;
inline int V_1D::_internal_item_size() const {
  return item_.size();
}
inline int V_1D::item_size() const {
  return _internal_item_size();
}
inline void V_1D::clear_item() {
  item_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 V_1D::_internal_item(int index) const {
  return item_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 V_1D::item(int index) const {
  // @@protoc_insertion_point(field_get:cache.V_1D.item)
  return _internal_item(index);
}
inline void V_1D::set_item(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  item_.Set(index, value);
  // @@protoc_insertion_point(field_set:cache.V_1D.item)
}
inline void V_1D::_internal_add_item(::PROTOBUF_NAMESPACE_ID::int32 value) {
  item_.Add(value);
}
inline void V_1D::add_item(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_item(value);
  // @@protoc_insertion_point(field_add:cache.V_1D.item)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
V_1D::_internal_item() const {
  return item_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
V_1D::item() const {
  // @@protoc_insertion_point(field_list:cache.V_1D.item)
  return _internal_item();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
V_1D::_internal_mutable_item() {
  return &item_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
V_1D::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:cache.V_1D.item)
  return _internal_mutable_item();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cache

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Cache_2eproto
